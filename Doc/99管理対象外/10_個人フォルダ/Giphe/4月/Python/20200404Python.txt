Python作業メモ

■課題
・mysql + python
・詳細設計PG
①座標→画像表示
②マップ表示（以下参照「選択座標」のグリッドと「集計座標」(x, y)形式
③ステータス表示（集計座標と同様）
※②，③はゆくゆくはDBから取得することを考慮
DB設計「キャラクタマスタ」張り替え
・F12で定義に
・unresolve imoprtのエラーを吐く
・ドキュメントルートの問題
→Displayをワークスペースに変更することで解決
→今後オートローダ機能のように動的にインポート（importにファイル名の身を指定）できるよう
にする必要がある。

↓参照（動的なモジュール取得ルート)	
import importlib

m = importlib.import_module('foo.some') # -> 'module'
m.__name__ # -> 'foo.some'

n = importlib.import_module('bar.some') # -> 'module'
n.__name__ # -> 'bar.some'

・main.pyでimport_moduleを用いる→ダイナミックインポートが可能


■Git完成版
tortoiseGit実装
https://github.com/pythonGame-RPG


■スケジュール
・ユーザインターフェースを取り急ぎ
・tortoiseGit実装予定
・pygame.vector
・imoportエラーの対処

■pygame解析
１．sprite→オブジェクト。Add, update(フック),killなど追加、除外、更新が可能
２．pygame.sprite.spritecollide
　→接触判定。接触しているものの一覧を返す。マッチング処理を実装可能。
３．pygame.sprite.collide_rect
　→rect属性を使って当たり判定を行う、比率変換したうえで当たり判定を調べる→collide_rect_ratio
　→radius属性の場合はrectでなくcircleで当たり判定を行うことが可能
　→mask属性の場合はmaskを使う。bitmaskが重なっているかどうかを判定する（グリッドの場合こちらの方がいいかも）
　→group属性の判定はgroupcollide
４．pygame.sprite.groupcollide
　→２つのgroup間で接触しているすべてのSpriteを探す
５．SpriteSheetクラスを作成→get_imageを定義し、1枚の画像からイラストを切り取る
６．ニューゲーム時はall_spritesとplatformsを初期化
　self.all_sprites = pg.sprite.Group()
　self.platforms = pg.sprite.Group()
７．settings.pyにSPRITESHEET、PLATFORMのパスを格納
８．xmlファイルでspritesheetの含有範囲を格納(<Subtexture name, x, y, height, width>
９．Surfaceでイメージの枠を作成image = pg.Surface((width, height))　#引数にタプル
１０．image.blitで切り取った画像を張り付ける
　→image.blit(self.spritesheet, (0, 0), (x, y, width, height))
１１．LayeredUpdates（pygame.spriteのライブラリ）
→レイヤーを制御し、OrderedUpdatesのように画像描写処理を行うLayeredUpdates
１２．キーボードのボタンを押して離すと、イベントキューにpygame.KEYDOWNイベントとpygame.KEYUPイベントが取得される
→キューは入れた順に取得される（押す→離すの場合、同様にKEYUP→KEYDOWNの順で取得される。）
→event.typeをKEYUP、KEYDOWNで判別すると同時押しなどのイベントを実装可能
１３．pg.display.flip()→display Surface全体を更新して画面に描写する
１４．pygame.display→ウィンドウ画面やスクリーンの制御を行うpygameモジュール
１５．wait_for_keyが曲者っぽい。


■ショートカット
shift + F10→右クリック
ctrl + shift + N → フォルダ作成


■機能概要
・マッチング取り込み前にマッチングを確定させる処理を追加

■■■■■
■■■■■
■■〇■■
■■■■■
■■■■■

縦横３マスに存在するキャラクタがマッチング対象となる
丸のマスを【集計座標】と命名。
集計座標を中心とする縦横５マス集計エリアを【選択座標】と命名。

１２３
４０５
６７８

〇は(x,y)座標でDB登録マッチング対象のピックアップは丸の座標で行う。
同じ座標にオブジェクトが存在しないようにするため〇と１－８の番号は主キーとする。

９マスに属するオブジェクト最大９ブロックでマッチングを行う
→乱数マスタでマッチング対象から除外される

★ブレイクで保持するキー項目
処理対象日-陣営id-パーティid-カルマ値

キャラクタマスタから全件取得して集計座標で回す。

パーティは全員がリーダーと同じ集計座標に存在すること。


■フォルダ構成
resource
┗Display
　┗Image
　　┗・・・
　　┗・・・
　┗Sound
┗Server
　┗Dao
　┗Dto
　┗Facade
┗Batch
　┗・・・
　┗frtproot # ファイルI/O
　┗send
　┗recv
┗Common
　┗BaseBatch
　┗Validator
　┗Const
┗LogTrace # 一括ログ管理
　┗DisplayLog
　┗BatchLog

→ディレクトリを当てている分処理が遅くなっていしまうことを危惧している。

■備考
・結局処理を開始するのもすべて__main__.pyなので処理構成は全てmainを修正
→Loginクラス
【解析結果】ここでループしていることが判明。for分に関してはpg.event.get():でnullが取得されるため。
→【課題２】GAMEオーバー画面からEnter押下後NewGame画面に遷移しない
→newgameでEnter押下後なg.new()に遷移（おそらくrunningフラグがTRUEになったため。）
→【課題３】デバッグ時にF5を連続実行すると画面が固まる。デバッグは停止（画面だけが表示された状態）
→同時実行を回避したい
→デバッグ時にrunning = False, waiting = Falseに変更後→g.new→g.show_start_screen→g.quit()
ウィンドウを閉じる結果におそらくフラグを変更した時点でshow～を切り抜けるように記述されている。
forループの外側にデバッグポイントを設置するのはナンセンス→設置するのはif文やfor,while文の内側。

【課題４】NewGameとGameOverの遷移、処理の終了をクリア
▼コメント
・main.pyのmainメソッドで処理中状態をキープする。
・wait_for_keysメソッドでユーザのキー入力を待つようにする
【課題５】コマンド画面でこれを指定、それぞれのキーを入力された場合を動的に判断して
それぞれのプログラムに渡せる仕組みを作りたい【難易度S】
【課題６】プログラムごとのrunningのような処理中フラグを作成→while self.running
【課題７】メニュー画面F1ボタン押下時→データ１を起動（F2、F3も同様）
パラメータ（画面IDとユーザ情報）をキーとして画面を呼び出す。
【課題８】ログイン画面の作成：ユーザIDとパスワードを入力しログインする仕様→データ選択
→Login()だけでlogin.pyのLoginの呼び出しが可能
【課題９】DAOは今後プログラム名を活用→仮としてログイン画面はSql.py(DAO)を実装(DTOは必要ない？)
【課題１０】DAOに同じようなDBの記述が入るのでDBAccessとして処理をまとめる。
→where文の作成OK
→pythonにおけるvalidate
①Cerberus→Pythonのオープンソースのバリデーションライブラリ
user_id,passwordに対するエラーそれぞれを判別できるようにする
▼辞書型
setdefault()：辞書[キー] = 値：キーがあれば更新、なければ追加
★次回validate続き
→入力form(show_start_screen)とvalidateの関係
form←→validate
value編集→項目ごとにエラー出力をまとめる,key(user_id,password)ごとにmergeする。【完了】
・DB→

■次回
https://stackoverflow.com/questions/46390231/how-to-create-a-text-input-box-with-pygame
ログイン画面の作成から。
